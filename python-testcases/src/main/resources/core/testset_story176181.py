"""
COPYRIGHT Ericsson 2019
The copyright to the computer program(s) herein is the property of
Ericsson Inc. The programs may be used and/or copied only with written
permission from Ericsson Inc. or in accordance with the terms and
conditions stipulated in the agreement/contract under which the
program(s) have been supplied.

@since:     February 2017
@author:    Patrick Bohan
@summary:   Integration tests for TORF-176181
            As a LITP user I want an "--exclude_nodes" option on
            "litp create_snapshot" so I can snapshot a deployment even
            though one node is unavailable
"""

import os
import re
from litp_generic_test import GenericTest, attr
from redhat_cmd_utils import RHCmdUtils
from rest_utils import RestUtils
import test_constants


class Story176181(GenericTest):
    """
    As a LITP user I want an "--exclude_nodes" option on "litp create_snapshot"
    so I can snapshot a deployment even though one node is unavailable
    """

    def setUp(self):
        """ Runs before every single test """
        super(Story176181, self).setUp()
        self.rhcmd = RHCmdUtils()
        self.ms1 = self.get_management_node_filename()

        # Part of the name of the dummy plugin
        self.plugin_id = "torf176181"

        self.ms_ip_address = self.get_node_att(self.ms1, 'ipv4')
        self.restutils = RestUtils(self.ms_ip_address)

        # Ensure that no snapshots exist
        self.remove_all_snapshots(self.ms1)

    def tearDown(self):
        """ Runs after every single test """

        super(Story176181, self).tearDown()
        # Ensure that no snapshots exist
        self.remove_all_snapshots(self.ms1)

    @staticmethod
    def get_local_rpm_paths(path, rpm_id):
        """
        Description:
        Method that returns a list of absolute paths to the
        RPMs required to be installed for testing

        Args:
            path (str): Path to location of rpms
            rpm_id (str): Part of the name of the rpm/s to be searched for

        Returns:
            list: list of rpm packages(If any found)
        """
        # get all RPMs in 'path' that contain 'rpm_substring' in their name
        rpm_names = [rpm for rpm in os.listdir(path) if rpm_id in rpm]

        if not rpm_names:
            return None

        # return a list of absolute paths to the RPMs found in 'rpm_names'
        return [
            os.path.join(rpath, rpm)
            for rpath, rpm in
            zip([os.path.abspath(path)] * len(rpm_names), rpm_names)
            ]

    def verify_appropriate_tasks_in_model(self, plan, list_of_excl_nodes):
        """
        Description:
        Method that verifies if a task per excluded node is in the plan

        Args:
            plan (dict): Plan details
            list_of_excl_nodes (list): list of nodes to be excluded
        """
        # The string used in tasks generated by dummy plugin
        task_desc = "is in the excluded list"
        node_task_in_plan = {}
        for node in list_of_excl_nodes:
            node_task_in_plan[node] = False

        for phase in plan['phases']:
            for cluster in plan['phases'][phase]:
                for task in plan['phases'][phase][cluster]:
                    if task_desc in task['desc']:
                        # Searching the plans task for description for string
                        search_result = re.search(\
                           r"(\S+)\s+{0}".format(task_desc), task['desc'])
                        if search_result:
                            node_task_in_plan[\
                                         str(search_result.groups()[0])] = True

        for node in list_of_excl_nodes:
            self.assertTrue(node_task_in_plan[node],
                            'Expected Task not in snapshot plan')

        for node in node_task_in_plan:
            self.assertTrue(node_task_in_plan[node],
                            'Unexpected Task in snapshot plan')

    def find_list_of_all_nodes(self):
        """
        Description:
            Function that will find all nodes in the deployment
        Args: -
        Returns:
                list_of_node_urls (dict): list of the nodes in the deployment
        """
        list_of_node_filenames = self.get_managed_node_filenames()
        self.log('info', list_of_node_filenames)

        list_of_node_urls = {}
        for node_filename in list_of_node_filenames:
            node_url = self.get_node_url_from_filename(self.ms1, node_filename)
            node_host_name = self.get_node_att(node_filename, 'hostname')
            list_of_node_urls[node_host_name] = node_url

        return list_of_node_urls

    def generate_exclude_options(self,
                                 num_nodes_to_exclude,
                                 list_of_node_urls):
        """
        Description:
        Method that generates the exclude options to be used by create_snapshot

        Args:
            num_nodes_to_exclude, (int): How many nodes to exclude
            list_of_excl_nodes (list): list of all nodes urls in deployment

        Returns:
            str : argument to be used by litp cli to create the snapshot
                  using the exclude option
            list: List of nodes to be excluded
        """
        list_of_exl_nodes = []
        self.log('info', type(list_of_node_urls))
        for index in range(0, num_nodes_to_exclude):
            list_of_exl_nodes.append(list_of_node_urls.keys()[index])

        exclude_node_arg = \
                   '--exclude_node=\"{0}\"'.format(",".join(list_of_exl_nodes))

        return exclude_node_arg, list_of_exl_nodes

    def install_dummy_plugin(self):
        """
        Function which will install the dummy plugin that is required for
        certain testcases
        """
        # Check if the plugin is already installed
        _, _, rcode = self.run_command(
            self.ms1, self.rhcmd.check_pkg_installed([self.plugin_id]),
            su_root=True)

        # If not, copy plugin and extension onto MS
        if rcode == 1:
            local_rpm_paths = self.get_local_rpm_paths(
                os.path.abspath(
                    os.path.join(os.path.dirname(__file__), 'plugins')
                ),
                self.plugin_id
            )
            self.assertTrue(
                self.copy_and_install_rpms(self.ms1, local_rpm_paths))

    def remove_dummy_plugin(self):
        """
        Function which will remove the dummy plugin that was
        previously installed
        """
        stdout, _, rcode = self.run_command(
            self.ms1, self.rhcmd.check_pkg_installed([self.plugin_id]),
            su_root=True)

        if rcode == 0:
            stdout, _, _ = self.remove_rpm_on_node(self.ms1, stdout[-1])
            self.assertNotEqual([], stdout)

    @attr('all', 'revert', 'story176181', 'story176181_tc03')
    def test_03_p_named_snapshot_one_node(self):
        """
        @tms_id: torf_176181_TC3
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list contains 1 peer node.
        @tms_description:
            To verify that the exclude_node option can be executed
            with 1 node passed in
        @tms_test_steps:
            @step: litp create_snapshot -n name=ombs exclude_list="node1"
            @result: Verify that the create snapshot plan was successful
            @result: Verify that the create_snapshot command returned 0
            @result: Verify that the dummy task is in plan
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            Dummy plugin is installed (this plugin will generate
            a task per excluded node).
            No other litp snapshots exist
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        list_of_node_urls = self.find_list_of_all_nodes()
        num_nodes_to_exclude = 1
        cmd, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)
        create_snapshot_args = "-n obms {0}".format(cmd)

        self.log('info', 'Execute create_snapshot command via the cli')
        self.execute_cli_createsnapshot_cmd(self.ms1,
                                            create_snapshot_args,
                                            add_to_cleanup=False)

        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that node task is in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176181', 'story176181_tc03')
    def test_04_p_named_snapshot_two_nodes(self):
        """
        @tms_id: torf_176181_TC4
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list contains 2 peer nodes.
        @tms_description:
            To verify that the exclude_list option can be executed
            with 2 nodes passed in
        @tms_test_steps:
            @step: litp create_snapshot -n name=
                                        ombs exclude_list="node1, node2"
            @result: Verify that the create snapshot plan iwas successful
            @result: Verify that the dummy tasks is in plan
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            Dummy plugin is installed (this plugin will generate
            a task per excluded node).
            No other litp snapshots exist
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 2
        cmd, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)
        create_snapshot_args = "-n obms {0}".format(cmd)

        self.log('info', 'Execute create_snapshot command via the cli')
        self.execute_cli_createsnapshot_cmd(self.ms1,
                                            create_snapshot_args,
                                            add_to_cleanup=False)

        ### Verify snapshot plan is complete"
        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that nodes tasks are in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176181', 'story176181_tc17')
    def test_17_p_named_snapshot_via_rest(self):
        """
        @tms_id: torf_176181_TC17
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list contains 1 peer node via rest api.
        @tms_description:
            To verify that the exclude_list option can be executed
            with 1 node passed in via the rest api
        @tms_test_steps:
            @step: create named snapshot via the rest api where
            1 node is excluded
            @result: Verify that the create snapshot plan was successful
            @result: Verify that the dummy task is in plan
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            Dummy plugin is installed (this plugin will generate
            a task per excluded node).
            No other litp snapshots exist
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 1
        _, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)

        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/ombs?exclude_nodes=" +\
                       "{0}".format(",".join(list_of_excl_nodes))

        _, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        expected_message = "Wrong status returned from rest API, " +\
                            "expecting {0}, received {1}".format("201",
                                                                 status)
        self.assertTrue(status == 201, expected_message)

        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that node task is in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176181', 'story176181_tc18')
    def test_18_n_validation_via_rest_host_not_in_model(self):
        """
        @tms_id: torf_176181_TC18
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Host is not in model via the Rest API
        @tms_description:
            To verify that validation occurs via the rest api when the
            hostname is not defined in the model
        @tms_test_steps:
            @step: create named snapshot via the rest api where
            node is not defined in the model
            @result: Verify that command fails with appropriate validation
            @result: Verify that the snapshot doesn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/ombs?exclude_nodes={0}".format("shrek")
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "Nonexistent hostnames in exclude_nodes' +\
                        ': {0}", "type": "InvalidRequestError"'.format("shrek")
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        # Verify that the snapshot item doesn't get created
        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc19')
    def test_19_n_validation_via_rest_hosts_not_in_model(self):
        """
        @tms_id: torf_176181_TC19
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Hosts are not in model via the Rest API
        @tms_description:
            To verify that validation occurs via the rest api when 2
            hostnames are not defined in the model
        @tms_test_steps:
            @step: create named snapshot via the rest api where 2
                   nodes are not defined in the model
            @result: Verify that command fails with appropriate
                     validation error
            @result: Verify that the snapshot doesn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """

        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/ombs?exclude_nodes={0},{1}".format("shrek",
                                                                      "donkey")
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring =\
            '"message": "Nonexistent hostnames in exclude_nodes: ' +\
            '{0},{1}", "type": "InvalidRequestError"'.format("shrek", "donkey")
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc20')
    def test_20_n_validation_via_rest_duplicate_hosts(self):
        """
        @tms_id: torf_176181_TC20
        @tms_requirements_id: TORF-176181
        @tms_title: A snapshot doesn't get created (via the rest api)
                    when exclude list contains duplicated hostnames
        @tms_description:
            Named Snapshot: Hosts are duplicates via the Rest API
        @tms_test_steps:
            @step: create named snapshot via the rest api where
                   excluded nodes are duplicates of each other
            @result: Verify that command fails with appropriation
                     validation error
            @result: Verify that the snapshot didn't get created
            @result: Verify that the snapshot doesn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 1
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        # Add duplicate node
        list_of_excl_nodes.append(list_of_excl_nodes[0])

        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = '/snapshots/ombs?exclude_nodes=' +\
                       '{0}'.format(",".join(list_of_excl_nodes))
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = \
            '"message": "exclude_nodes contains duplicate entries: ' +\
            '{0}", "type": "InvalidRequestError"'.format(list_of_excl_nodes[0])
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc21')
    def test_21_n_validation_via_rest_empty_string(self):
        """
        @tms_id: torf_176181_TC21
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list is an empty string via the Rest API.
        @tms_description:
            To verify that when the the exclude_nodes option is empty,
            a validation error will occur
        @tms_test_steps:
            @step: create named snapshot via the rest api where
            the exclude list option is an empty string
            @result: Verify that the command fails with an appropriate
                     validation error
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        self.log('info', 'Execute create_snapshot command via the rest api')
        stdout, _, status = \
            self.restutils.post("/snapshots/ombs?exclude_nodes=\"\"",
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "exclude_nodes cannot be an empty ' +\
                        'string", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc22')
    def test_22_n_validation_via_rest_missing_list(self):
        """
        @tms_id: torf_176181_TC22
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Empty Exclude list via the Rest API
        @tms_description:
            To verify that the exclude_list is empty via the Rest API
        @tms_test_steps:
            @step: create named snapshot via the rest api where
            the exclude list option is empty
            @result: Verify that the command failed with appropriate validation
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        self.log('info', 'Execute create_snapshot command via the rest api')
        stdout, _, status = \
            self.restutils.post("/snapshots/ombs?exclude_nodes=",
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "exclude_nodes cannot be an empty ' +\
                        'string", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc23')
    def test_23_n_validation_via_rest_partial_empty_string(self):
        """
        @tms_id: torf_176181_TC23
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Partial empty Exclude list via the Rest API
        @tms_description:
            To verify that when the exclude_list is partially empty
             via the Rest API that an appropriate error occurs
        @tms_test_steps:
            @step: create named snapshot via the rest api where
            excluded nodes list is node1,,node2
            @result: Verify that the command failed with an appropriate error
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 2
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        excluded_nodes = '{0},,{1}'.format(list_of_excl_nodes[0],
                                           list_of_excl_nodes[1])

        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/ombs?exclude_nodes=" +\
                       "{0}".format(excluded_nodes)
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "exclude_nodes malformed", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc24')
    def test_24_n_validation_via_rest_deployment(self):
        """
        @tms_id: torf_176181_TC24
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list and deployment snapshots
                            via the Rest API
        @tms_description:
            To verify that the exclude_list option can not be used
            with deployment snapshots via the Rest API
        @tms_test_steps:
            @step: create deployment snapshot via the rest api where
            1 node is excluded
            @result: Verify that the command fails with an appropriate
                     error message
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 2
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/snapshot?exclude_nodes=" +\
                       "{0}".format(",".join(list_of_excl_nodes))
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "Use exclude_nodes with named snapshot' +\
                        ' only", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc25')
    def test_25_n_validation_via_rest_invalid_host(self):
        """
        @tms_id: torf_176181_TC25
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list contains invalid host
        @tms_description:
            To verify that when the exclude_list contains invalid host name
            via the rest api and an appropriate error occurs
        @tms_test_steps:
            @step: create named snapshot via the rest api where
                   the exclude list contains an invalid host
            @result: Verify that the command failed with an appropriate error
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        self.log('info', 'Execute create_snapshot command via the rest api')
        stdout, _, status = \
            self.restutils.post("/snapshots/ombs?exclude_nodes=!node1",
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "exclude_nodes malformed", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))

    @attr('all', 'revert', 'story176181', 'story176181_tc27')
    def test_27_n_validation_via_rest_ms(self):
        """
        @tms_id: torf_176181_TC27
        @tms_requirements_id: TORF-176181
        @tms_title:
            Named Snapshot: Exclude list contains MS as host
        @tms_description:
            To verify that when the exclude_list contains the MS
            via the rest api and an appropriate error occurs
        @tms_test_steps:
            @step: create named snapshot via the rest api
                   where the exclude list contains the MS
            @result: Verify that the command failed with an appropriate error
            @result: Verify that the snapshot didn't get created
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exist
        @tms_execution_type: Automated
        """
        self.log('info', 'Execute create_snapshot command via the rest api')
        rest_command = "/snapshots/ombs?exclude_nodes={0}".format(self.ms1)
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        self.log('info', 'Verify the error message')
        exp_substring = '"message": "exclude_nodes cannot contain MS", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response: \n{0}".format(stdout))

        self.log('info', 'Verify https status code')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verify that the snapshot didn\'t get created')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertEqual(0, len(snapshot_list))
