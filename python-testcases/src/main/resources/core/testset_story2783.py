'''
COPYRIGHT Ericsson 2019
The copyright to the computer program(s) herein is the property of
Ericsson Inc. The programs may be used and/or copied only with written
permission from Ericsson Inc. or in accordance with the terms and
conditions stipulated in the agreement/contract under which the
program(s) have been supplied.

@since:     April 2014
@author:    Ares
@summary:   Integration test for ___
            Agile:
                Epic:
                Story: LITPCDS-2783
                Sub-Task: LITPCDS-3489, LITPCDS-3483, LITPCDS-3484
'''

import os
import time
import test_constants as const
from litp_generic_test import GenericTest, attr
from litp_cli_utils import CLIUtils
from rest_utils import RestUtils
from redhat_cmd_utils import RHCmdUtils


class Story2783(GenericTest):
    """
    LITPCDS-2783: As a plugin developer, I want to store the state in the
    model, so that values generated generated by tasks are available later in
    the plan.
    """

    def setUp(self):
        """
        Description:
            Runs before every test to perform the test setup
        """
        # call super class setup
        super(Story2783, self).setUp()
        # get the cluster information for the test
        self.management_node = self.get_management_node_filename()
        self.management_ip = self.get_node_att(self.management_node, 'ipv4')
        # setup required utilities for the test
        self.cli = CLIUtils()
        self.rest = RestUtils(self.management_ip)
        self.rhc = RHCmdUtils()
        # plugin rpm used by the test
        self.test_plugins = (
        'ERIClitpstory2783api_CXP1234567.rpm',
        'ERIClitpstory2783_CXP1234567.rpm')
        # item type extension name
        self.item_extension = 'story2783_extension'
        # plugin name
        self.plugin = 'story2783'
        # model urls, property values and item type used in this test
        self.item_type = 'story2783'
        self.plugin_model_item = '/story_2783'
        self.properties = (
        'name=\'test_{0}\'',
        'rest_only=\'{0}\'',
        'plugin_only=\'{0}\'',
        'both=\'{0}\'',
        'none=\'{0}\'',
        'view=\'{0}\'')
        # path to xml files
        self.remote_filepath = '/tmp/'
        # xml files
        self.xml_readonly = 'update_readonly_story2783.xml'
        self.xml_invalid_link = 'link_invalid_story2783.xml'
        self.xml_no_value = 'update_none_story2783.xml'
        self.xml_value = 'update_value_story2783.xml'

    def tearDown(self):
        """
        Description:
            Runs after every test to perform the test teardown/cleanup
        """

        # call super class teardown

        super(Story2783, self).tearDown()

    def _get_local_filepath(self, path, isdir=False):
        """
        Description:
            Get the local filepath to the test currently running and use it to
            retrieve the requested directory or file which must be copied onto
            the node under test
        """

        # get the directory path of where the current test file is located
        local_path = os.path.dirname(repr(__file__).strip('\''))
        # check that the local path to test file holds the requested
        # path
        self.assertTrue(self.is_text_in_list(path, os.listdir(local_path)),
            '\'{0}\' not found in directory \'{1}\' - listing \'{2}\''.\
            format(path, local_path, os.listdir(local_path)))
        if isdir:
            # check that requested path is really a directory
            self.assertTrue(os.path.isdir('{0}/{1}'.format(local_path, path)),
                '\'{0}/{1}\' is not a directory'.format(local_path, path))
            return '{0}/{1}'.format(local_path, path)
        else:
            # check that requested path is really a file
            self.assertTrue(os.path.isfile('{0}/{1}'.format(local_path, path)),
                '\'{0}/{1}\' is not a file'.format(local_path, path))
            return '{0}/{1}'.format(local_path, path)

    def _is_plugin_installed(self, plugin):
        """
        Desrcription:
            Check if the required dummy plugins, for the test to run, are
            already installed from a previous test run
        """

        # check if the given plugin rpm is installed or not
        _, stderr, rcode = self.run_command(self.management_node,
                        self.rhc.check_pkg_installed([plugin]))
        self.assertEqual([], stderr)
        if rcode == 0:
            return True

        return False

    def _check_installed_plugins(self):
        """
        Description:
            Check which, if any, dummy plugins are installed and get the list
            of those which aren't but are required
        """

        plugins_require_install = list()
        # for each plugin rpm in tuple test plugins, check if the rpm is
        # already installed and if not, mark it for installation
        for plugin in self.test_plugins:
            if not self._is_plugin_installed(plugin.split('.rpm')[0]):
                plugins_require_install.append(plugin)

        return plugins_require_install

    def _install_plugins(self):
        """
        Description:
            For any dummy plugin, required by the test, that aren't installed,
            install them
        """

        plugins_require_install = self._check_installed_plugins()
        if plugins_require_install:
            # get the local filepath to the plugin rpm directory
            local_path = self._get_local_filepath('plugins', isdir=True)
            # for each plugin marked for installation, copy the rpm to the
            # management node where the test is running on
            for plugin in plugins_require_install:
                local_filepath = '{0}/{1}'.format(local_path, plugin)
                self.assertTrue(self.copy_file_to(self.management_node,
                                local_filepath, const.LITP_PKG_REPO_DIR,
                                                root_copy=True,
                                                  add_to_cleanup=False),
                    'Failed to copy file \'{0}\' to \'{1}\' on node \'{2}\''.\
                    format(local_filepath, const.LITP_PKG_REPO_DIR,
                                                        self.management_node))
            # recreate the yum repository to recognise the newly copied rpm
            # files
            stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_createrepo_cmd(
                                                    const.LITP_PKG_REPO_DIR),
                                                su_root=True)
            self.assertEqual(0, rcode)
            self.assertEqual([], stderr)
            self.assertNotEqual([], stdout)
            # remove the .rpm extension from each of the plugins marked for
            # installation so yum will be able to recognise them and install
            # them
            plugins_require_install[:] = [plugin.split('.rpm')[0] \
                                         for plugin in plugins_require_install]
            # install the rpm files using yum
            stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_yum_install_cmd(
                                                    plugins_require_install),
                                                su_root=True)
            self.assertEqual(0, rcode)
            self.assertEqual([], stderr)
            self.assertNotEqual([], stdout)
            # check that the plugins were successfully installed
            for plugin in plugins_require_install:
                self.assertTrue(self._is_plugin_installed(plugin),
                'Failed to install plugin \'{0}\''.format(plugin))
        self.restart_litpd_service(self.management_node)
        self._check_plugin_is_registered()

    def _check_plugin_is_registered(self):
        """
        Description:
            Check the plugins required for the test run are registered with the
            litpd service
        """

        # check the plugin is registered with the litpd service
        expected_info_logs = ['INFO: Added ModelExtension: \\"{0}\\"'.format(
                                                        self.item_extension),
                              'INFO: Added Plugin: \\"{0}\\"'.format(
                                                                self.plugin)]
        stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_grep_file_cmd(
                                                    const.GEN_SYSTEM_LOG_PATH,
                                                    expected_info_logs),
                                                su_root=True)
        self.assertEqual(0, rcode)
        self.assertEqual([], stderr)
        self.assertNotEqual([], stdout)

    def _copy_xml_test_file(self, xml_file):
        """
        Description:
            Copy the XML file, required for a particular test, onto the node
            under test
        """

        # get the local filepath to the xml test files
        local_filepath = self._get_local_filepath(xml_file)
        self.assertTrue(self.copy_file_to(self.management_node, local_filepath,
                                         self.remote_filepath),
            'Failed to copy file \'{0}\' to \'{1}\' on node \'{2}\''.format(
                local_filepath, self.remote_filepath, self.management_node))

    def obsolete_01_n_callbacktask_updates_property_not_allowed(self):
        """
        Obsolete - tested by UTs in
            ERIClitpcore/test/test_litp/test_query_item.py

        Description:
            Using a plugin, attempt to update a property which has the plugin
            updatable flag set to False

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. Execute the create_plan command
            3. The plugin will attempt to update a property value that does not
               have the plugin updatable flag set to True
            4. Wait for the plan execution to fail
            5. Check /var/log/messages for error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The update attempt, during plan execution, must fail and an error
            message will be logged in /var/log/messages
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('01'),
                                     self.properties[1].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute the 'create_plan' command
        self.execute_cli_createplan_cmd(self.management_node)
        # execute the 'show_plan' command and check that the task for test url
        # exists
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout),
            'Expected callback task for \'{0}\' not found in plan'.format(
                                                        plugin_model_item_url))
        # execute the 'run_plan' command and wait for plan to fail
        self.execute_cli_runplan_cmd(self.management_node)
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_FAILED),
            'Plan expected to fail, but didn\'t')
        # check /var/log/messages for expected error logs
        expected_error_logs = ['ERROR: Unhandled exception running task:',
                               '_update_property:',
                               'is not updatable by plugins']
        stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_grep_file_cmd(
                                                    const.GEN_SYSTEM_LOG_PATH,
                                                    expected_error_logs),
                                                su_root=True)
        self.assertEqual(0, rcode)
        self.assertEqual([], stderr)
        self.assertNotEqual([], stdout)

    def obsolete_02_n_create_xml_link_for_plugin_updatable_property(self):
        """
        Description:
            Create a model item and use an XML file to attempt to link the
            model item to a node, which will fail with an appropriate error
            message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. Set the plugin updatable property to some value
            3. Load an XML file into the model to create a link
            4. Use the plugin updatable property value for the link
            5. Check for link creation error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The link creation attempt must fail with an appropriate error
            message

        TC not applicable due to link removal. Loading for inherit XMLs does
        not disallow updating of plugin updatable properties - 4347 covers the
        positive case for loading.
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # copy the required xml file for the test to the node under test
        self._copy_xml_test_file(self.xml_invalid_link)
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set in the xml file but for this
        # particular negative case, it's irrelevant; where it will be relevant
        # that the values match, it can be retrieved from the model
        properties = '{0} {1}'.format(self.properties[0].format('02'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # get the ms url
        ms_ = self.find(self.management_node, '/', 'ms')[0]
        self.assertNotEqual('', ms_)
        # get the software-item url child of ms url
        software_item_url = self.find(self.management_node, ms_,
                                    'software-item',
                                    rtn_type_children=False)[0]
        # execute the xml 'load' command to attempt to create a link for the ms
        # and check that the appropriate error message is returned
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_invalid_link)
        _, stderr, _ = self.execute_cli_load_cmd(self.management_node,
                                                software_item_url, filepath,
                                                expect_positive=False)
        expect_err = \
                'Unable to link to a property that is updatable by plugins:'
        self.assertTrue(self.is_text_in_list(expect_err, stderr),
            'Expected error message \'{0}\' not found in stderr: \'{1}\''.\
                                                    format(expect_err, stderr))

    def obsolete_03_n_create_cli_link_for_plugin_updatable_property(self):
        """
        Description:
            Create a model item and attempt to link it to a node, using the
            CLI, which must fail with an appropriate error message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. Set the plugin updatable property to some value
            3. Execute the link command on a node item in the model tree
            4. Use the plugin updatable property value for the link
            5. Check for link creation error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The link creation attempt must fail with an appropriate error
            message

        TC no longer valid due to link removal. Inherit not applicable to this
        case as updates to children are allowed, proved by TC in 4026
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('03'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # get the ms url
        ms_ = self.find(self.management_node, '/', 'ms')[0]
        # get the software-item url child of ms url
        software_item_url = self.find(self.management_node, ms_,
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to ms software-item url and execute the cli
        # 'link' command to attempt to create a link for the ms and check that
        # the appropriate error message is returned
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('03'),
                                      self.properties[2].format(
                                                            str(time.time())))
        # pylint is complaining about link method
        #_, stderr, _ = self.execute_cli_link_cmd(self.management_node,
        #                                        plugin_model_item_url,
        #                                        self.item_type, properties,
        #                                        expect_positive=False)
        #self.assertNotEqual([], stderr)
        #expect_err = \
        #        'Unable to link to a property that is updatable by plugins:'
        #self.assertTrue(self.is_text_in_list(expect_err, stderr),
        #    'Expected error message \'{0}\' not found in stderr: \'{1}\''.\
        #                                           format(expect_err, stderr))

    def obsolete_04_n_create_rest_link_for_plugin_updatable_property(self):
        """
        Description:
            Create a model item and attempt to link it, using a REST POST
            request, which must fail with an appropriate error message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. Set the plugin updatable property to some value
            3. Execute a REST POST to attempt to create a link to a node item
               in the model tree
            4. Use the plugin updatable property value for the link
            5. Check for REST status and error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The REST POST link creation attempt must fail with appropriate
            error message

        TC no longer valid due to link removal. Inherit not applicable to this
        case as updates to children are allowed, proved by TC in 4026
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                        'software-item',
                                        rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('04'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # get the ms url
        ms_ = self.find(self.management_node, '/', 'ms')[0]
        # get the software-item url child of ms url
        software_item_url = self.find(self.management_node, ms_,
                                    'software-item',
                                    rtn_type_children=False)[0]
        # execute a rest 'post' to attempt to create a link for the ms and
        # check that an appropriate error status and message is returned
        data = '{{"id": "{0}","link": "{1}", "properties": {{"{2}": {3},'\
               '"{4}": "{5}"}}}}'.format(self.plugin_model_item.strip('/'),
                                        self.item_type,
                                        self.properties[0].split('=')[0],
                                        self.properties[0].split('=')[1].\
                                            replace('\'', '"').format('04'),
                                        self.properties[2].split('=')[0],
                                        str(time.time()))
        stdout, stderr, status = self.rest.post(software_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(422, status)
        self.assertEqual('', stderr)
        expect_err = 'PropertyNotAllowedError'
        self.assertTrue(expect_err in stdout,
            'Expected error message \'{0}\' not found in \'{1}\''.format(
                                                        expect_err, stdout))

    @attr('all', 'non-revert', 'story2783', 'story2783_tc05')
    def test_05_n_cli_update_readonly_plugin_updatable_property(self):
        """
        Note: Merged TC07
        Description:
            Create a model item, with a read only property, which is only
            updatable by a plugin, and attempt to update it using the CLI that
            will fail with an appropriate error message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using the CLI update command
            4. Check for invalid update error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The update attempt using the CLI must fail
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                        rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('05'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute the cli 'update' command to attempt to update the readonly
        # property and check that an appropriate error message is returned
        properties = '{0}'.format(self.properties[2].format(str(time.time())))
        # updating this as fix for LITPCDS-7578 is in and update of properties
        # that are updateable_rest=False are now updatables when in Initial
        # state
        self.assertEqual(
            'Initial',
            self.execute_show_data_cmd(
                self.management_node, plugin_model_item_url, 'state'
            )
        )
        self.execute_cli_update_cmd(self.management_node,
                                    plugin_model_item_url, properties)
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        readonly_property = \
            self.cli.get_properties(stdout)[self.properties[2].split('=')[0]]
        # try to export the readonly property and check that it doesn't appear
        # in the xml file
        filepath = '{0}{1}'.format(self.remote_filepath, 'readonly_export.xml')
        self.execute_cli_export_cmd(self.management_node,
                                    plugin_model_item_url, filepath)
        expect_match = [self.properties[2].split('=')[0], readonly_property]
        stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_grep_file_cmd(
                                                    filepath, expect_match))
        self.assertEqual(0, rcode)
        self.assertEqual([], stderr)
        self.assertNotEqual([], stdout)
        self.assertTrue(
            self.is_text_in_list('this property is not updatable', stdout))
        # execute a rest 'post' to attempt to update the readonly property and
        # check that an appropriate error status and message is returned
        # updating REST also for LITPCDS-7578
        data = '{{"properties": {{"{0}": "{1}"}}}}'.format(
                                            self.properties[2].split('=')[0],
                                            str(time.time()))
        stdout, stderr, status = self.rest.put(plugin_model_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(200, status)
        self.assertEqual('', stderr)
        # now that there is a fix for LITPCDS-7578, we need to actually run a
        # plan so that we can verify that the item isn't updatable in an
        # Applied state
        self.execute_cli_createplan_cmd(self.management_node)
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(
            self.wait_for_plan_state(self.management_node, const.PLAN_COMPLETE)
        )
        properties = '{0}'.format(self.properties[2].format(str(time.time())))
        self.assertEqual(
            'Applied',
            self.execute_show_data_cmd(
                self.management_node, plugin_model_item_url, 'state'
            )
        )
        _, stderr, _ = self.execute_cli_update_cmd(self.management_node,
                                                  plugin_model_item_url,
                                                  properties,
                                                  expect_positive=False)
        self.assertNotEqual([], stderr)
        expect_err = 'Unable to modify readonly property:'
        self.assertTrue(self.is_text_in_list(expect_err, stderr),
            'Expected error message \'{0}\' not found in stderr: \'{1}\''.\
                                                    format(expect_err, stderr))
        data = '{{"properties": {{"{0}": "{1}"}}}}'.format(
                                            self.properties[2].split('=')[0],
                                            str(time.time()))
        stdout, stderr, status = self.rest.put(plugin_model_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(422, status)
        self.assertEqual('', stderr)
        expect_err = 'InvalidRequestError'
        self.assertTrue(expect_err in stdout,
            'Expected error message \'{0}\' not found in \'{1}\''.format(
                                                        expect_err, stdout))

    def obsolete_06_n_xml_update_readonly_plugin_updatable_property(self):
        """
        Description:
            Create a model item, with a read only property, which is only
            updatable by a plugin, and attempt to update it using an XML file
            with --merge that will fail with an appropriate error message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using an XML file with the
               load --merge command
            4. Check for invalid update error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The XML load must fail with an appropriate error message
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # copy the required xml file for the test to the node under test
        self._copy_xml_test_file(self.xml_readonly)
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set in the xml file but for this
        # particular negative case, it's irrelevant; where it will be relevant
        # that the values match, it can be retrieved from the model
        properties = '{0} {1}'.format(self.properties[0].format('06'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the xml 'load' command to attempt to create a link for the ms
        # and check that the appropriate error message is returned
        filepath = '{0}{1}'.format(self.remote_filepath,
                                  self.xml_readonly)
        plugin_updatable_property_value = self.execute_show_data_cmd(
                self.management_node, software_item_url,
                self.properties[2].split('=')[0])
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                filepath, '--merge')
        self.assertEqual(
            plugin_updatable_property_value,
            self.execute_show_data_cmd(
                self.management_node,
                software_item_url,
                self.properties[2].split('=')[0])
        )

    @attr('all', 'non-revert')
    def obsolete_07_n_rest_update_readonly_plugin_updatable_property(self):
        """
        Note: Merged into TC05
        Description:
            Create a model item, with a read only property, which is only
            updatable by a plugin, and attempt to update it using a REST PUT
            request that will fail with an appropriate error message

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using a REST PUT request
            4. Check for invalid update error message

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The REST request will fail with an appropriate error message
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0} {1}'.format(self.properties[0].format('07'),
                                     self.properties[2].format(
                                                            str(time.time())))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute a rest 'post' to attempt to update the readonly property and
        # check that an appropriate error status and message is returned
        data = '{{"properties": {{"{0}": "{1}"}}}}'.format(
                                            self.properties[2].split('=')[0],
                                            str(time.time()))
        stdout, stderr, status = self.rest.put(plugin_model_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(422, status)
        self.assertEqual('', stderr)
        expect_err = 'PropertyNotAllowedError'
        self.assertTrue(expect_err in stdout,
            'Expected error message \'{0}\' not found in \'{1}\''.format(
                                                        expect_err, stdout))

    @attr('all', 'non-revert', 'story2783', 'story2783_tc08')
    def test_08_p_cli_update_plugin_updatable_property(self):
        """
        NOTE: TC09 merged into this test
        Description:
            Create a model item, with a property updatable by a plugin, and
            attempt to update it using the CLI that will succeed

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using the CLI update command
            4. Check the property value is indeed updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The CLI update of the plugin updatable property will succeed
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # copy the required xml file for the test to the node under test
        self._copy_xml_test_file(self.xml_no_value)
        self._copy_xml_test_file(self.xml_value)
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('08'))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute the cli 'update' command to attempt to update the plugin
        # property
        properties = '{0}'.format(self.properties[3].format(str(time.time())))
        self.execute_cli_update_cmd(self.management_node,
                                    plugin_model_item_url, properties)
        plugin_property = self.execute_show_data_cmd(self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[3].\
                                                                split('=')[0])
        # try to export the property and check that it appears in the xml file
        filepath = '{0}{1}'.format(self.remote_filepath, 'plugin_export.xml')
        self.execute_cli_export_cmd(self.management_node,
                                    plugin_model_item_url, filepath)
        expect_match = [self.properties[3].split('=')[0], plugin_property]
        stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_grep_file_cmd(
                                                    filepath, expect_match))
        self.assertEqual(0, rcode)
        self.assertEqual([], stderr)
        self.assertNotEqual([], stdout)
        # execute the xml 'load' command to update the value of the plugin
        # property with no value and check the property isn't viewable
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_no_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--replace')
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[3].split('=')[0],
                                  expect_positive=False)
        # execute the xml 'load' command to update the value of the plugin
        # property with a value and check that the property can now be viewed
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--merge')
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertTrue(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout),
            'Expected property \'{0}\' not found in stdout: \'{1}\''.format(
                                            self.properties[3].split('=')[0],
                                            stdout))
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                    self.properties[3].split('=')[0])

    @attr('all', 'non-revert')
    def obsolete_09_p_xml_update_plugin_updatable_property(self):
        """
        NOTE: Obsolete and merged into TC08
        Description:
            Create a model item, with a property updatable by a plugin, and
            attempt to update it using an XML file with the load --merge
            command

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using an XML file with the load
               --merge command
            4. Check the property value is indeed updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The XML file update will succeed
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # copy the required xml file for the test to the node under test
        self._copy_xml_test_file(self.xml_no_value)
        self._copy_xml_test_file(self.xml_value)
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set in the xml file but for this
        # particular negative case, it's irrelevant; where it will be relevant
        # that the values match, it can be retrieved from the model
        properties = '{0}'.format(self.properties[0].format('09'))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertFalse(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout),
            'Property \'{0}\' was not expected in stdout: \'{1}\''.format(
                                            self.properties[3].split('=')[0],
                                            stdout))
        # execute the xml 'load' command to update the value of the plugin
        # property with no value and check the property isn't viewable
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_no_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--merge')
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[3].split('=')[0],
                                  expect_positive=False)
        # execute the xml 'load' command to update the value of the plugin
        # property with a value and check that the property can now be viewed
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--merge')
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertTrue(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout),
            'Expected property \'{0}\' not found in stdout: \'{1}\''.format(
                                            self.properties[3].split('=')[0],
                                            stdout))
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                    self.properties[3].split('=')[0])

    @attr('all', 'non-revert', 'story2783', 'story2783_tc10')
    def test_10_p_rest_update_plugin_updatable_property(self):
        """
        Description:
            Create a model item, with a property updatable by a plugin, and
            attempt to update it using a REST PUT request that will succeed

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1. Execute the create command on an item in the model tree
            2. The property value for the item type must have a default value
               set on creation
            3. Try to update the property value using a REST PUT request
            4. Check the property value is indeed updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The update through the REST request must succeed
        """

        # check if test plugin is installed, and if not, install it
        self._install_plugins()
        # get the software-item url from the model tree
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url id to software-item url and execute the 'create'
        # command to create the item in the model tree with its required
        # properties
        # time.time() is used to retrieve a simple value for the property and
        # will be different than what is set during the 'link command but for
        # this particular negative case, it's irrelevant; where it will be
        # relevant that the values match, it can be retrieved from the model
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('10'))
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute a rest 'post' to attempt to update the readonly property and
        # check that an appropriate error status and message is returned
        data = '{{"properties": {{"{0}": "{1}"}}}}'.format(
                                            self.properties[3].split('=')[0],
                                            str(time.time()))
        stdout, stderr, status = self.rest.put(plugin_model_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(200, status)
        self.assertEqual('', stderr)
        self.assertNotEqual('', stdout)
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertTrue(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout),
            'Expected property \'{0}\' not found in stdout: \'{1}\''.format(
                                            self.properties[3].split('=')[0],
                                            stdout))
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                    self.properties[3].split('=')[0])

    @attr('all', 'non-revert', 'story2783', 'story2783_tc11')
    def test_11_p_check_status_change_plugin_property_xml(self):
        """
        Description:
            Create a model item in the model tree and update it using a plugin,
            which must succeed; the model item will be set to state Initial on
            creation and will change to Applied on plan success; the same
            property value will be updated once again successfully, using an
            XML file with the load --merge command and the state will change to
            Updated

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the property value is updated
            8.  Check the item's state is set to Applied
            9.  Import an XML file with load --merge
            10. Check the item's state is set to Updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The states must be successfully updated throughout each model item
            change
        """

        # check if the required plugins for test are installed and if not,
        # install them
        self._install_plugins()
        # copy the XML files required for the test
        self._copy_xml_test_file(self.xml_value)
        self._copy_xml_test_file(self.xml_no_value)
        # get the url of software-item from the model and append the url to be
        # created by the test along with the required properties
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('11'))
        # execute the create command
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url, self.item_type,
                                    properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # check the state of the item is Initial
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # execute the show command and check that the plugin updatable property
        # does not exist in the show output
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertFalse(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout))
        # execute the show_plan command and check there exists a task for the
        # test plugin
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for the plan to complete
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check the state of the item is now set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # check the plugin updatable property is now viewable from the show
        # command
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                    self.properties[3].split('=')[0])
        # load the XML file to update the property with no value
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_no_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--merge')
        # check the state of the item is now Updated
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.execute_cli_show_cmd(self.management_node, plugin_model_item_url)
        self.assertEqual('Applied', state)
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[3].split('=')[0])
        # load the XML file to update the property with a new value
        filepath = '{0}{1}'.format(self.remote_filepath, self.xml_value)
        self.execute_cli_load_cmd(self.management_node, software_item_url,
                                 filepath, '--merge')
        # check the item state is now Updated
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Updated', state)
        # check the property is viewable again with the value passed from the
        #XML file
        plugin_property = self.execute_show_data_cmd(self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[3].\
                                                                split('=')[0])
        self.assertEqual('1396355578.35', plugin_property)

    @attr('all', 'non-revert', 'story2783', 'story2783_tc12')
    def test_12_p_check_status_change_plugin_property_cli(self):
        """
        Description:
            Create a model item in the model tree and update it using a plugin,
            which must succeed; the model item will be set to state Initial on
            creation and will change to Applied on plan success; the same
            property value will be updated once again successfully, using the
            CLI and the state will change to Updated

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the property value is updated
            8.  Check the item's state is set to Applied
            9.  Update the model item with the CLI update command
            10. Check the item's state is set to Updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The states must be successfully updated throughout each model item
            change
        """

        # check if the plugins required for the test are installed and, if not,
        # install them
        self._install_plugins()
        # get the software-item url
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the url required for the test and its properties
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('12'))
        # execute the create command
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # check the state of the item is set to Initial
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # check that the plugin updatable property is not viewable in the show
        # output
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[3].split('=')[0],
                                  expect_positive=False)
        # execute the show_plan command and check a task for the test model
        # exists
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for the plan to complete
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check the state of the model item is set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # check the plugin updatable property is now viewable in the show
        # output
        plugin_property = self.execute_show_data_cmd(self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[3].\
                                                                split('=')[0])
        # execute the update command on the model item to update the property
        self.execute_cli_update_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.properties[3].format(
                                                            str(time.time())))
        # check the state of the model item is now Updated
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Updated', state)
        # check the property value is updated
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertNotEqual(plugin_property,
                            self.execute_show_data_cmd(self.management_node,
                                                      plugin_model_item_url,
                                                      self.properties[3].\
                                                                split('=')[0]))

    @attr('all', 'non-revert', 'story2783', 'story2783_tc13')
    def test_13_p_check_status_change_plugin_pyoperty_rest(self):
        """
        Description:
            Create a model item in the model tree and update it using a plugin,
            which must succeed; the model item will be set to state Initial on
            creation and will change to Applied on plan success; the same
            property value will be updated once again successfully, using a
            REST put request and the state will change to Updated

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the property value is updated
            8.  Check the item's state is set to Applied
            9.  Update the model item with a REST PUT request
            10. Check the item's state is set to Updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The states must be successfully updated throughout each model item
            change
        """

        # check if the plugins required for the test are installed and, if not,
        # install them
        self._install_plugins()
        # get the software-item url and append the test url and properties
        # required
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('13'))
        # execute the create command for the model item
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command and check the item state is Initial
        self.execute_cli_createplan_cmd(self.management_node)
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # execute the show command and check the plugin property cannot be
        # viewed
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[3].split('=')[0],
                                  expect_positive=False)
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertFalse(self.is_text_in_list(self.properties[3].split('=')[0],
                                             stdout))
        # execute the show_plan command and check there is a task for the test
        # url
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for plan to complete
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check the model item state is set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # execute the show_cmd and check the plugin property can now be viewed
        plugin_property = self.execute_show_data_cmd(self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[3].\
                                                                split('=')[0])
        # execute a rest 'put' request to update the plugin property
        data = '{{"properties": {{"{0}": "{1}"}}}}'.format(
                                            self.properties[3].split('=')[0],
                                            str(time.time()))
        stdout, stderr, status = self.rest.put(plugin_model_item_url,
                                                self.rest.HEADER_JSON, data)
        self.assertEqual(200, status)
        self.assertEqual('', stderr)
        self.assertNotEqual('', stdout)
        # check the item state is now set to Updated
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Updated', state)
        # execute the show command and check the property value is updated
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertNotEqual(plugin_property,
                            self.cli.get_properties(stdout)[
                                            self.properties[3].split('=')[0]])

    def obsolete_14_p_check_no_status_change_plugin_property(self):
        """
        Obsolete - replaced by an AT:
            ERIClitpcore/ats/testset_story2783/\
                test_14_p_check_no_status_change_plugin_property.at
        Description:
            Create a model item in the model tree and update it using a plugin,
            which must succeed; the model item will be set to state Initial on
            creation and will change to Applied on plan success; the same
            property value will be updated once again successfully by the
            plugin but the state must remain unchanged

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the property value is updated
            8.  Check the item's state is set to Applied
            9.  Execute the create_plan command
            10. Execute the run_plan command
            11. Check the state doesn't change throughout the plan run
            12. Check the item's property value is updated

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The property value must be updated by the plugin, but the state
            must remain unchanged if it is in Applied state
        """

        # check if the plugin required by the test is installed and, if not,
        # install it
        self._install_plugins()
        # get the url of software-item and append the test url and it
        # properties
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('14'))
        # execute the create command for the model item
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # check the item state is set to Initial
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # check the property is not viewable in the show output
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                   self.properties[2].split('=')[0],
                                   expect_positive=False)
        # check the task for the test exists in the plan
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for plan completion
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check the model item state is set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # check the property is viewable and has a value
        plugin_property = self.execute_show_data_cmd(self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[2].\
                                                                split('=')[0])
        # get the url of software-item and append the test url and it
        # properties
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url_2 = '{0}{1}_1'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('14'))
        # execute the create command for the model item
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url_2,
                                    self.item_type, properties)
        # execute the create_plan command again
        self.execute_cli_createplan_cmd(self.management_node)
        # check there is a task for the test url in the plan
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list('Initial', stdout))
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and check plan is Running
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_IN_PROGRESS))
        # check the state of the model item is still in state Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # wait for plan completion
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check the state of the model item is set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)
        # check the property value is updated
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertNotEqual(plugin_property,
                            self.cli.get_properties(stdout)[
                                            self.properties[2].split('=')[0]])

    # @attr('all', 'non-revert', '2783')
    def obsolete_15_p_ordered_task_list_plugin_property(self):
        """
        Obsoleted:
        replaced with AT:
        ERIClitpcore/ats/testset_story2783/\
            test_15_p_ordered_task_list_plugin_property.at

        Description:
            Use an OrderedTaskList() of CallbackTasks() to update the plugin
            updatable property multiple times throughout the plan and check it
            gets updated

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the property value is updated by the first CallbackTask()
            8.  Check the item's state is still set to Initial
            9.  Check the property value is updated by the second
                CallbackTask()
            10. Check plan completes successfully
            11. Check the state is then set to Applied

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            The property value will change multiple times throughout the plan
            execution but the state will be set to Applied only after
            successful plan execution
        """

        # check if the plugin required for the test is installed and, if not,
        # install it
        self._install_plugins()
        # get the software-item url and append the test url
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        properties = '{0}'.format(self.properties[0].format('15'))
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                self.plugin_model_item)
        # execute the create command to create the test url
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # check the state of the item is Initial
        state = self.execute_show_data_cmd(self.management_node,
                                            plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # check that the plugin property is not viewable
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[2].split('=')[0],
                                  expect_positive=False)
        # check that the task for the plugin is the plan
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command
        self.execute_cli_runplan_cmd(self.management_node)
        task_01_property = ''
        task_02_property = ''
        # while the plan is running, check the state of the item is Initial,
        # and check which task is currently running in the plan and get the
        # value of the plugin property currently
        while self.get_current_plan_state(self.management_node) == \
                                      const.PLAN_IN_PROGRESS:
            stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                    plugin_model_item_url)
            state = self.execute_show_data_cmd(self.management_node,
                                              plugin_model_item_url, 'state')
            if self.is_text_in_list(self.properties[2].split('=')[0], stdout):
                std_out, _, _ = self.execute_cli_showplan_cmd(
                                                        self.management_node)
                for line in std_out:
                    if 'Running\t\t' in line and \
                        'task 01:' in std_out[std_out.index(line) + 1]:
                        plugin_property = self.execute_show_data_cmd(
                                                    self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[2].\
                                                            split('=')[0])
                        task_01_property = plugin_property
                    elif 'Running\t\t' in line and \
                        'task 02:' in std_out[std_out.index(line) + 1]:
                        plugin_property = self.execute_show_data_cmd(
                                                    self.management_node,
                                                    plugin_model_item_url,
                                                    self.properties[2].\
                                                            split('=')[0])
                        task_02_property = plugin_property
        # check the plan completes successfully
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_COMPLETE))
        # check that the property value is not empty for each task and that the
        # property was updated by each task during the plan execution
        self.assertNotEqual('', task_01_property)
        self.assertNotEqual('', task_02_property)
        self.assertNotEqual(task_01_property, task_02_property)
        # check the state of the item is set to Applied
        state = self.execute_show_data_cmd(self.management_node,
                                          plugin_model_item_url, 'state')
        self.assertEqual('Applied', state)

    @attr('all', 'non-revert', 'story2783', 'story2783_tc16')
    def test_16_n_update_plugin_property_fails(self):
        """
        Description:
            When a plan execution fails, the model item state does not change
            to Applied and the property value is not updated

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Wait for the plan to Fail
            8.  Check the item's state is not set to Applied
            12. Check the item's property value remains unchanged

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            A falied plan execution will not change the property value or the
            model item state
        """

        # check if the required plugin for the test is installed and, if not,
        # install it
        self._install_plugins()
        # get the software-item url and append the test url and properties to
        # it
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('16'))
        # execute the create command for the test url
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # execute the show command and check the state of the item is in state
        # Initial
        state = self.execute_show_data_cmd(self.management_node,
                                          plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # check that the plugin property is not viewable
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[4].split('=')[0],
                                  expect_positive=False)
        # execute the show_plan command and check a task for the plugin exists
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for the plan to fail
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_FAILED))
        # check the state of the item is still Initial
        state = self.execute_show_data_cmd(self.management_node,
                                          plugin_model_item_url, 'state')
        self.assertEqual(
            'Initial (deployment of properties indeterminable)',
            state)
        # check the plugin property is not viewable
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[4].split('=')[0],
                                  expect_positive=False)

    @attr('all', 'non-revert', 'story2783', 'story2783_tc17')
    def test_17_n_update_plugin_view_property_fails(self):
        """
        Description:
            Attempting to update a View() property using a plugin will fail

        Pre-Requisites:
            1. A running litpd service
            2. An installed and configured cluster

        Risks:
            1. Once a model item type extension is installed and registered
               with the litpd service, it cannot be removed
            2. Once a plugin is installed and registered with the litpd
               service, it cannot be removed

        Pre-Test Steps:
            1. Create a new dummy item type extension as described in the
               LITP 2 SDK
            2. Create a new dummy plugin as described in the LITP 2 SDK
            3. Edit the item type extension to make use of plugin updatable
               properties
            4. Edit the plugin to make use of the item type extension updatable
               property
            5. Build and install the item type extension
            6. Build and install the plugin

        Test Steps:
            1.  Execute the create command on an item in the model tree
            2.  The property value for the item type must have a default value
                set on creation
            3.  Execute the create_plan command
            4.  Check the item's state is set to Initial
            5.  Check the property value
            6.  Execute the run_plan command
            7.  Check the plan execution Fail
            8.  Check /var/log/messages for View() is not a Property() error

        Restore Steps:
            1. Remove the created model item from the model tree
            2. Execute the create_plan command

        Expected Result:
            A plugin cannot alter a View() property
       """

        # check if the plugin required for the test is installed and, if not,
        # install it
        self._install_plugins()
        # get the software-item url
        software_item_url = self.find(self.management_node, '/software',
                                    'software-item',
                                    rtn_type_children=False)[0]
        # append the test url and properties to software-item
        plugin_model_item_url = '{0}{1}'.format(software_item_url,
                                                self.plugin_model_item)
        properties = '{0}'.format(self.properties[0].format('17'))
        # execute the create command for the item
        self.execute_cli_create_cmd(self.management_node,
                                    plugin_model_item_url,
                                    self.item_type, properties)
        # execute the create_plan command
        self.execute_cli_createplan_cmd(self.management_node)
        # check the item is in Initial state
        state = self.execute_show_data_cmd(self.management_node,
                                          plugin_model_item_url, 'state')
        self.assertEqual('Initial', state)
        # execute the show command and check the plugin property is not vieable
        stdout, _, _ = self.execute_cli_show_cmd(self.management_node,
                                                plugin_model_item_url, '-j',
                                                load_json=False)
        self.assertFalse(self.is_text_in_list(self.properties[5].split('=')[0],
                                             stdout))
        # execute the show_plan and check there is a task for the plugin
        stdout, _, _ = self.execute_cli_showplan_cmd(self.management_node)
        self.assertTrue(self.is_text_in_list(self.plugin_model_item, stdout))
        # execute the run_plan command and wait for plan to fail
        self.execute_cli_runplan_cmd(self.management_node)
        self.assertTrue(self.wait_for_plan_state(self.management_node,
                                                const.PLAN_FAILED))
        # check the state of the item is still Initial
        state = self.execute_show_data_cmd(self.management_node,
                                          plugin_model_item_url, 'state')
        self.assertEqual(
            'Initial (deployment of properties indeterminable)', state)

        # check the property isn't viewable
        self.execute_show_data_cmd(self.management_node, plugin_model_item_url,
                                  self.properties[5].split('=')[0],
                                  expect_positive=False)
        # check /var/log/messages for expected error logs
        expected_error_logs = ['ERROR: Unhandled exception running task:',
                               'AttributeError: Field'.format(
                                            self.properties[5].split('=')[0]),
                               'is not a Property']
        stdout, stderr, rcode = self.run_command(self.management_node,
                                                self.rhc.get_grep_file_cmd(
                                                    const.GEN_SYSTEM_LOG_PATH,
                                                    expected_error_logs),
                                                su_root=True)
        self.assertEqual(0, rcode)
        self.assertEqual([], stderr)
        self.assertNotEqual([], stdout)
