"""
COPYRIGHT Ericsson 2019
The copyright to the computer program(s) herein is the property of
Ericsson Inc. The programs may be used and/or copied only with written
permission from Ericsson Inc. or in accordance with the terms and
conditions stipulated in the agreement/contract under which the
program(s) have been supplied.

@since:     February 2017
@author:    Patrick Bohan
@summary:   Integration tests for TORF-176198
            As a LITP user I want an "--exclude_nodes" option on
            "litp remove_snapshot" command so I can remove a
            snapshot even though one node is unavailable
"""

import os
import re
from litp_generic_test import GenericTest, attr
from redhat_cmd_utils import RHCmdUtils
from rest_utils import RestUtils

import test_constants


class Story176198(GenericTest):
    """
    As a LITP user I want an "--exclude_nodes" option on "litp remove_snapshot"
    so I can snapshot a deployment even though one node is unavailable
    """

    def setUp(self):
        """ Runs before every single test """
        super(Story176198, self).setUp()
        self.rhcmd = RHCmdUtils()
        self.ms1 = self.get_management_node_filename()

        # Part of the name of the dummy plugin
        self.plugin_id = "torf176181"

        # The string used in tasks generated by dummy plugin
        self.ms_ip_address = self.get_node_att(self.ms1, 'ipv4')
        self.restutils = RestUtils(self.ms_ip_address)

        # Ensure that no snapshots exist
        self.remove_all_snapshots(self.ms1)

    def tearDown(self):
        """ Runs after every single test """

        super(Story176198, self).tearDown()
        # Ensure that no snapshots exist
        self.remove_all_snapshots(self.ms1)

    @staticmethod
    def get_local_rpm_paths(path, rpm_id):
        """
        Description:
        Method that returns a list of absolute paths to the
        RPMs required to be installed for testing

        Args:
            path (str): Path to location of rpms
            rpm_id (str): Part of the name of the rpm/s to be searched for

        Returns:
            list: list of rpm packages(if list empty there is an error
                                       in theframework of the test)
        """
        # get all RPMs in 'path' that contain 'rpm_substring' in their name
        rpm_names = [rpm for rpm in os.listdir(path) if rpm_id in rpm]

        if not rpm_names:
            return None

        # return a list of absolute paths to the RPMs found in 'rpm_names'
        return [
            os.path.join(rpath, rpm)
            for rpath, rpm in
            zip([os.path.abspath(path)] * len(rpm_names), rpm_names)
            ]

    def verify_appropriate_tasks_in_model(self, plan, list_of_excl_nodes):
        """
        Description:
        Method that verifies if a task per excluded node is in the plan

        Args:
            plan (dict): Plan details
            list_of_excl_nodes (list): list of nodes to be excluded
        """

        task_desc = "is in the excluded list"
        node_task_in_plan = {}
        for node in list_of_excl_nodes:
            node_task_in_plan[node] = False

        for phase in plan['phases']:
            for cluster in plan['phases'][phase]:
                for task in plan['phases'][phase][cluster]:
                    if task_desc in task['desc']:
                        # Search for expected task in plan based ont
                        # he task description
                        search_result = re.search(\
                           r"(\S+)\s+{0}".format(task_desc), task['desc'])
                        if search_result:
                            node_task_in_plan[\
                                         str(search_result.groups()[0])] = True

        for node in list_of_excl_nodes:
            self.assertTrue(node_task_in_plan[node],
                            'Expected Task not in snapshot plan')

        for node in node_task_in_plan:
            self.assertTrue(node_task_in_plan[node],
                            'Unexpected Task in snapshot plan')

    def find_list_of_all_nodes(self):
        """
        Description:
            Function that will find all nodes in the deployment
        Args: -
        Returns:
            list_of_node_urls (dict): list of the nodes in the deployment
        """
        list_of_node_filenames = self.get_managed_node_filenames()
        self.log('info', list_of_node_filenames)

        list_of_node_urls = {}
        for node_filename in list_of_node_filenames:
            node_url = self.get_node_url_from_filename(self.ms1, node_filename)
            node_host_name = self.get_node_att(node_filename, 'hostname')
            list_of_node_urls[node_host_name] = node_url

        return list_of_node_urls

    def generate_exclude_options(self,
                                 num_nodes_to_exclude,
                                 list_of_node_urls):
        """
        Description:
        Method that generates the exclude options to be used by create_snapshot

        Args:
            num_nodes_to_exclude, (int): How many nodes to exclude
            list_of_excl_nodes (list): list of all nodes in deployment

        Returns:
            str : argument to be used when passing in excluded nodes
                  during remove_snapshot
            list: List of nodes to be excluded
        """
        list_of_exl_nodes = []
        self.log('info', type(list_of_node_urls))
        for index in range(0, num_nodes_to_exclude):
            list_of_exl_nodes.append(list_of_node_urls.keys()[index])

        exclude_node_arg = \
                   '--exclude_node=\"{0}\"'.format(",".join(list_of_exl_nodes))

        return exclude_node_arg, list_of_exl_nodes

    def install_dummy_plugin(self):
        """
        Function which will install the dummy plugin that is required for
        certain testcases
        """
        # Check if the plugin is already installed
        _, _, rcode = self.run_command(
            self.ms1, self.rhcmd.check_pkg_installed([self.plugin_id]),
            su_root=True)

        # If not, copy plugin and extension onto MS
        if rcode == 1:
            local_rpm_paths = self.get_local_rpm_paths(
                os.path.abspath(
                    os.path.join(os.path.dirname(__file__), 'plugins')
                ),
                self.plugin_id
            )
            self.assertTrue(
                self.copy_and_install_rpms(self.ms1, local_rpm_paths))

    def remove_dummy_plugin(self):
        """
        Function which will remove the dummy plugin that was
        previously installed
        """
        stdout, _, rcode = self.run_command(
            self.ms1, self.rhcmd.check_pkg_installed([self.plugin_id]),
            su_root=True)

        if rcode == 0:
            stdout, _, _ = self.remove_rpm_on_node(self.ms1, stdout[-1])
            self.assertNotEqual([], stdout)

    def create_named_snapshot(self):
        """
        Function which will create a named snapshot and wait for
        snapshot plan to complete
        """
        self.log('info', 'Creating Named snapshot')
        self.execute_cli_createsnapshot_cmd(self.ms1,
                                            "-n ombs",
                                            add_to_cleanup=False)

        ### Verify snapshot plan is complete"
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

    @attr('all', 'revert', 'story176198', 'story176198_tc03')
    def test_03_p_named_snapshot_one_node(self):
        """
        @tms_id: torf_176198_TC3
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list contains 1 peer node.
        @tms_description:
            To verify that the exclude_node option can be executed
            with 1 node passed in
        @tms_test_steps:
            @step: Install dummy plugin
            @result: Plugin installed
            @step: litp create_snapshot -n name=ombs
            @result: Named snapshot exists
            @step: litp remove_snapshot -n name=ombs exclude_list="node1"
            @result: Verify that the remove snapshot plan was successful
            @result: Verify that the remove_snapshot command returned 0
            @result: Verify that the snapshot has been removed
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exists
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        self.create_named_snapshot()
        list_of_node_urls = self.find_list_of_all_nodes()
        num_nodes_to_exclude = 1
        cmd, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)
        remove_snapshot_args = "-n ombs {0}".format(cmd)

        self.log('info',
                 "Removing a named snapshot, expecting a positive result")
        self.execute_cli_removesnapshot_cmd(self.ms1,
                                            remove_snapshot_args,
                                            add_to_cleanup=False)

        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that node1 task is in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176198', 'story176198_tc04')
    def test_04_p_named_snapshot_two_nodes(self):
        """
        @tms_id: torf_176198_TC4
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list contains 2 peer nodes.
        @tms_description:
            To verify that the exclude_list option can be executed
            with 2 nodes passed in
        @tms_test_steps:
            @step: Install dummy plugin
            @result: Plugin installed
            @step: litp create_snapshot -n name=ombs
            @result: Named snapshot exists
            @step: litp remove_snapshot -n name=
                                        ombs exclude_list="node1, node2"
            @result: Verify that the remove snapshot plan was successful
            @result: Verify that the snapshot has been removed
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exists
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        self.create_named_snapshot()
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 2
        cmd, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)
        remove_snapshot_args = "-n ombs {0}".format(cmd)

        self.log('info',
                 "Removing a named snapshot, expecting a positive result")
        self.execute_cli_removesnapshot_cmd(self.ms1,
                                            remove_snapshot_args,
                                            add_to_cleanup=False)

        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that node1 task is in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176198', 'story176198_tc17')
    def test_17_p_named_snapshot_via_rest(self):
        """
        @tms_id: torf_176198_TC17
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list contains 1 peer node using
                            the rest api.
        @tms_description:
            To verify that the exclude_list option can be executed
            with 1 node passed in via the rest api
        @tms_test_steps:
            @step: Install dummy plugin
            @result: Plugin installed
            @step: litp create_snapshot -n name=ombs
            @result: Named snapshot exists
            @step: remove named snapshot via the rest api where
            1 node is excluded
            @result: Verify that the remove snapshot plan was successful
            @result: Verify that the snapshot has been removed
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            No other litp snapshots exists
        @tms_execution_type: Automated
        """

        self.install_dummy_plugin()
        self.create_named_snapshot()
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 1
        _, list_of_excl_nodes = \
                            self.generate_exclude_options(num_nodes_to_exclude,
                                                          list_of_node_urls)

        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/ombs?exclude_nodes=" +\
                       "{0}".format(",".join(list_of_excl_nodes))

        _, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        error_message = "Wrong status returned from rest API, " +\
                            "expecting {0}, received {1}".format("201",
                                                                 status)

        self.log('info', "Checking response message from rest api")
        self.assertTrue(status == 200, error_message)

        self.log('info', 'Verify snapshot plan is complete')
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        ### Get plan data ###
        plan = self.get_plan_data(self.ms1)

        self.log('info', 'Verify that node1 task is in the snapshot plan')
        self.verify_appropriate_tasks_in_model(plan, list_of_excl_nodes)

        self.remove_dummy_plugin()

    @attr('all', 'revert', 'story176198', 'story176198_tc18')
    def test_18_n_validation_via_rest_host_not_in_model(self):
        """
        @tms_id: torf_176198_TC18
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Host is not in model via the Rest API
        @tms_description:
            To verify that validation occurs via the rest api when the
            hostname is not defined in the model
        @tms_test_steps:
            @step: node is not defined in the model
            @result: Verify that command fails with appropriate validation
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            named snapshot exists
        @tms_execution_type: Automated
        """

        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/ombs?exclude_nodes={0}".format("shrek")
        stdout, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "Nonexistent hostnames in exclude_nodes' +\
                        ': {0}", "type": "InvalidRequestError"'.format("shrek")
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc19')
    def test_19_n_validation_via_rest_hosts_not_in_model(self):
        """
        @tms_id: torf_176198_TC19
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Hosts are not in model via the Rest API
        @tms_description:
            To verify that validation occurs via the rest api when 2
            hostnames are not defined in the model
        @tms_test_steps:
            remove named snapshot via the rest api where 2
            nodes are not defined in the model
            @result: Verify that command fails with appropriate
                     validation error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/ombs?exclude_nodes=" +\
                        "{0},{1},{2}".format("shrek", "node1", "donkey")

        stdout, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring =\
            '"message": "Nonexistent hostnames in exclude_nodes: ' +\
            '{0},{1}", "type": "InvalidRequestError"'.format("shrek", "donkey")
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc20')
    def test_20_n_validation_via_rest_duplicate_hosts(self):
        """
        @tms_id: torf_176198_TC20
        @tms_requirements_id: TORF-176198
        @tms_title:
                   Named Snapshot: Duplicate hosts via the Rest API
        @tms_description:
            Named Snapshot: Hosts are duplicates via the Rest API
        @tms_test_steps:
            @step: remove named snapshot via the rest api where
            nodes are duplicates of each other
            @result: Verify that command fails with appropriate
                     validation error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 1
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        # Add duplicate node
        list_of_excl_nodes.append(list_of_excl_nodes[0])

        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = '/snapshots/ombs?exclude_nodes=' +\
                       '{0}'.format(",".join(list_of_excl_nodes))
        stdout, _, status = \
            self.restutils.delete(rest_command,
                                  "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = \
            '"message": "exclude_nodes contains duplicate entries: ' +\
            '{0}", "type": "InvalidRequestError"'.format(list_of_excl_nodes[0])
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc21')
    def test_21_n_validation_via_rest_empty_string(self):
        """
        @tms_id: torf_176198_TC21
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list is an empty string via the Rest API.
        @tms_description:
            To verify that when the the exclude_nodes option is empty,
            a validation error will occur
        @tms_test_steps:
            @step: remove named snapshot via the rest api where
            the exclude list option is an empty string
            @result: Verify that the command fails with an appropriate
                     validation error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
            Named snapshots exists
        @tms_execution_type: Automated
        """
        self.log('info', "Removing a named snapshot via the rest api")
        stdout, _, status = \
            self.restutils.delete("/snapshots/ombs?exclude_nodes=\"\"",
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "exclude_nodes cannot be an empty ' +\
                        'string", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc22')
    def test_22_n_validation_via_rest_empty_list(self):
        """
        @tms_id: torf_176198_TC22
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Empty Exclude list via the Rest API
        @tms_description:
            To verify that the exclude_list is empty via the Rest API
        @tms_test_steps:
            @step: removed named snapshot via the rest api where
            the exclude list option is empty
            @result: Verify that the command failed with appropriate validation
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        self.log('info', "Removing a named snapshot via the rest api")
        stdout, _, status = \
            self.restutils.delete("/snapshots/ombs?exclude_nodes=",
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "exclude_nodes cannot be an empty ' +\
                        'string", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc23')
    def test_23_n_validation_via_rest_partial_empty_string(self):
        """
        @tms_id: torf_176198_TC23
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Partial empty Exclude list via the Rest API
        @tms_description:
            To verify that when the exclude_list is partially empty
             via the Rest API that an appropriate error occurs
        @tms_test_steps:
            @step: remove named snapshot via the rest api where
            excluded nodes list is node1,,node2
            @result: Verify that the command failed with an appropriate error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()

        num_nodes_to_exclude = 2
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        excluded_nodes = '{0},,{1}'.format(list_of_excl_nodes[0],
                                           list_of_excl_nodes[1])

        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/ombs?exclude_nodes=" +\
                       "{0}".format(excluded_nodes)
        stdout, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "exclude_nodes malformed", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc24')
    def test_24_n_validation_via_rest_deployment_snapshot(self):
        """
        @tms_id: torf_176198_TC24
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list and deployment snapshots
                            via the Rest API
        @tms_description:
            To verify that the exclude_list option can not be used
            with deployment snapshots via the Rest API
        @tms_test_steps:
            @step: remove deployment snapshot via the rest api where
            1 node is excluded
            @result: Verify that the command fails with an appropriate
                     error message
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        list_of_node_urls = self.find_list_of_all_nodes()
        num_nodes_to_exclude = 2
        _, list_of_excl_nodes = \
            self.generate_exclude_options(num_nodes_to_exclude,
                                          list_of_node_urls)

        self.log('info', "Creating a deployment snapshot via the rest api")
        rest_command = "/snapshots/snapshot"
        stdout, _, status = \
            self.restutils.post(rest_command,
                                "Content-Type:application/json",
                                "{\"type\":\"snapshot-base\"}")

        ### Verify snapshot plan is complete"
        self.wait_for_plan_state(self.ms1, test_constants.PLAN_COMPLETE)

        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/snapshot?exclude_nodes=" +\
                       "{0}".format(list_of_excl_nodes[0])
        stdout, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "Use exclude_nodes with named snapshot' +\
                        ' only", "type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

        self.log('info', 'Verifying that the snapshot isn\'t removed')
        snapshot_list = self.find(self.ms1, "/snapshots",
                                  "snapshot-base", assert_not_empty=False)
        self.assertTrue(1, len(snapshot_list))
        self.assertTrue(['/snapshots/snapshot'], snapshot_list)

    @attr('all', 'revert', 'story176198', 'story176198_tc25')
    def test_25_n_validation_via_rest_invalid_host(self):
        """
        @tms_id: torf_176198_TC25
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list contains invalid host
        @tms_description:
            To verify that when the exclude_list contains in valid host name
            via the rest api and appropriate error occurs
        @tms_test_steps:
            @step: remove named snapshot via the rest api where
                   where the exclude list contains an invalid host
            @result: Verify that the command failed with an appropriate error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        self.log('info', "Removing a named snapshot via the rest api")
        stdout, _, status = \
            self.restutils.delete("/snapshots/ombs?exclude_nodes=!node1",
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "exclude_nodes malformed", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)

    @attr('all', 'revert', 'story176198', 'story176198_tc26')
    def test_26_n_validation_via_rest_ms(self):
        """
        @tms_id: torf_176198_TC26
        @tms_requirements_id: TORF-176198
        @tms_title:
            Named Snapshot: Exclude list contains MS as host
        @tms_description:
            To verify that when the exclude_list contains the MS
            via the rest api and appropriate error occurs
        @tms_test_steps:
            @step: remove named snapshot via the rest api where
                   where the exclude list contains the MS
            @result: Verify that the command failed with an appropriate error
        @tms_test_precondition:
            A LITP deployment has been successfully deployed with the
            exclude_list functionality.
        @tms_execution_type: Automated
        """
        self.log('info', "Removing a named snapshot via the rest api")
        rest_command = "/snapshots/ombs?exclude_nodes={0}".format(self.ms1)
        stdout, _, status = \
            self.restutils.delete(rest_command,
                                "Content-Type:application/json")

        self.log('info', 'Verifying the correct message is received')
        exp_substring = '"message": "exclude_nodes cannot contain MS", ' +\
                        '"type": "InvalidRequestError"'
        self.assertTrue(exp_substring in stdout,
                        "Unexpected rest api response")

        self.log('info', 'Verifying the httpd return status')
        error_msg = "Wrong status returned from rest API, expecting " +\
                    "{0}, received {1}".format("422", status)
        self.assertTrue(status == 422, error_msg)
